#![feature(file_buffered)]

use std::fs::File;
use std::io::{BufWriter, Write};
use std::path::PathBuf;

use proc_macro2::TokenStream;
use qubit_config::general::{Device, Processor};
use qubit_config::linker::output_linker_script;
use quote::quote;

// #[cfg(device = "supported")]
qubit_macros::import_device!(QUBIT_AUTHOR, QUBIT_MODEL);

fn check_exclusive_pins() {
	if let Some(led_pin) = device::LED_PIN {
		assert!(!device::ROW_PINS.contains(&led_pin), "Pin used in more than one place.");
		assert!(!device::COL_PINS.contains(&led_pin), "Pin used in more than one place.");
	}

	assert!(
		!device::ROW_PINS.iter().any(|x| device::COL_PINS.contains(x)),
		"Pin used in more than one place."
	);
}

fn keyboard_tokens() -> TokenStream {
	let processor = device::PROCESSOR.as_str();

	let keymap = device::LAYER0.0.iter().map(|row| {
		let row_tokens = row.iter().map(|&n| proc_macro2::Literal::u8_unsuffixed(n));

		quote! { [#(#row_tokens),*] }
	});

	let rows: Vec<_> = device::ROW_PINS
		.iter()
		.map(|&pin| pin.parse::<TokenStream>().unwrap())
		.collect();

	let cols: Vec<_> = device::COL_PINS
		.iter()
		.map(|&pin| pin.parse::<TokenStream>().unwrap())
		.collect();

	quote! {
		#[derive(Debug)]
		#[::qubit_macros::keyboard_matrix(
			processor = #processor,
			keymap = [#(#keymap),*],
			rows = [#(#rows),*],
			cols = [#(#cols),*]
		)]
		pub struct KeyboardMatrix;
	}
}

fn codegen(file: &mut BufWriter<File>) {
	let device_path = {
		let author_val = env!("QUBIT_AUTHOR");
		let model_val = env!("QUBIT_MODEL");

		let author = syn::Ident::new(author_val, proc_macro2::Span::call_site());
		let model = syn::Ident::new(model_val, proc_macro2::Span::call_site());

		quote! { pub use ::qubit_device::models::#author::#model::*; }
	};

	let keyboard_tokens = keyboard_tokens();

	let tokens = quote! {
		#[comment = " This file is automatically generated and not intended for manual editing."]

		#device_path

		#keyboard_tokens
	};

	let parsed: syn::File = syn::parse2(tokens).unwrap();
	let formatted = prettyplease::unparse(&parsed);

	file.write_all(formatted.as_bytes()).unwrap();
}

fn processor_cfgs(p: Processor) {
	match p {
		Processor::RP2040 => {}
		Processor::STM32F411 => {
			println!("cargo::rustc-cfg=stm32f411_bank_b");

			println!("cargo::rustc-check-cfg=cfg(stm32f411_bank_b)");
			println!("cargo::rustc-check-cfg=cfg(stm32f411_bank_c)");
			println!("cargo::rustc-check-cfg=cfg(stm32f411_bank_d)");
			println!("cargo::rustc-check-cfg=cfg(stm32f411_bank_e)");
			println!("cargo::rustc-check-cfg=cfg(stm32f411_bank_h)");
		}
	}
}

fn main() {
	let out = std::env::var_os("OUT_DIR").unwrap();
	let out = PathBuf::from(out);

	check_exclusive_pins();

	let mut codegen_file = File::create_buffered(out.join("codegen.rs")).unwrap();
	codegen(&mut codegen_file);

	let processor = device::PROCESSOR;

	let memory_x = {
		const KEYMAP_SIZE: usize = device::LAYER0.get_packed_size();

		output_linker_script::<qubit_config::keyboard::KeyboardConfiguration<KEYMAP_SIZE>>(
			processor,
			device::FLASH,
			device::DEVICE,
		)
	};

	let mut mem_x_file = File::create(out.join("memory.x")).unwrap();
	mem_x_file.write_all(memory_x.as_bytes()).unwrap();

	println!("cargo:rustc-link-search={}", out.display());

	println!("cargo:rustc-link-arg-bins=--nmagic");
	println!("cargo:rustc-link-arg-bins=-Tlink.x");
	// println!("cargo:rustc-link-arg-bins=-Tlink-rp.x");

	if std::env::var("CARGO_FEATURE_DEFMT").is_ok() {
		println!("cargo:rustc-link-arg-bins=-Tdefmt.x");
	}

	match device::DEVICE {
		Device::Keyboard => {
			println!("cargo::rustc-cfg=keyboard");
		}
	}

	processor_cfgs(processor);

	if device::LED_PIN.is_some() {
		println!("cargo::rustc-cfg=has_led");
	}

	println!("cargo::rustc-check-cfg=cfg(has_led)");
}
