#![feature(file_buffered)]

use std::fs::File;
use std::io::{BufWriter, Write};
use std::path::PathBuf;

use proc_macro2::TokenStream;
use qubit_config::cargo::BuildCfgs;
use qubit_config::general::Device;
use qubit_config::linker::output_linker_script;
use quote::quote;

// TODO: RA doesn't seem to work with `target-applies-to-host` option in config.toml
// even though it builds just fine with cargo.
// #[cfg(device = "import")]
qubit_macros::import_device!(QUBIT_AUTHOR, QUBIT_MODEL);

fn keyboard_tokens() -> TokenStream {
	let mcu = device::MCU.as_str();

	let keymap = device::LAYER0.0.iter().map(|row| {
		let row_tokens = row.iter().map(|&n| proc_macro2::Literal::u8_unsuffixed(n));

		quote! { [#(#row_tokens),*] }
	});

	let rows: Vec<_> = device::ROW_PINS
		.iter()
		.map(|&pin| pin.parse::<TokenStream>().unwrap())
		.collect();

	let cols: Vec<_> = device::COL_PINS
		.iter()
		.map(|&pin| pin.parse::<TokenStream>().unwrap())
		.collect();

	quote! {
		#[derive(Debug)]
		#[::qubit_macros::keyboard_matrix(
			mcu = #mcu,
			keymap = [#(#keymap),*],
			rows = [#(#rows),*],
			cols = [#(#cols),*]
		)]
		pub struct KeyboardMatrix;
	}
}

fn codegen(file: &mut BufWriter<File>) {
	let device_path = {
		let author_val = env!("QUBIT_AUTHOR");
		let model_val = env!("QUBIT_MODEL");

		let author = syn::Ident::new(author_val, proc_macro2::Span::call_site());
		let model = syn::Ident::new(model_val, proc_macro2::Span::call_site());

		quote! { pub use ::qubit_device::models::#author::#model::*; }
	};

	let keyboard_tokens = keyboard_tokens();

	let tokens = quote! {
		#[comment = " This file is automatically generated and not intended for manual editing."]

		#device_path

		#keyboard_tokens
	};

	let parsed: syn::File = syn::parse2(tokens).unwrap();
	let formatted = prettyplease::unparse(&parsed);

	file.write_all(formatted.as_bytes()).unwrap();
}

fn main() {
	let out = std::env::var_os("OUT_DIR").unwrap();
	let out = PathBuf::from(out);

	let mut codegen_file = File::create_buffered(out.join("codegen.rs")).unwrap();
	codegen(&mut codegen_file);

	let mcu = device::MCU;
	let device_type = device::DEVICE;

	let memory_x = {
		const KEYMAP_SIZE: usize = device::LAYER0.get_packed_size();

		output_linker_script::<qubit_config::keyboard::KeyboardConfiguration<KEYMAP_SIZE>>(
			mcu,
			device::FLASH,
			device_type,
		)
	};

	let mut mem_x_file = File::create(out.join("memory.x")).unwrap();
	mem_x_file.write_all(memory_x.as_bytes()).unwrap();

	println!("cargo:rustc-link-search={}", out.display());

	println!("cargo:rustc-link-arg-bins=--nmagic");
	println!("cargo:rustc-link-arg-bins=-Tlink.x");
	// println!("cargo:rustc-link-arg-bins=-Tlink-rp.x");

	if std::env::var("CARGO_FEATURE_DEFMT").is_ok() {
		println!("cargo:rustc-link-arg-bins=-Tdefmt.x");
	}

	let mut build_cfgs = BuildCfgs::new();

	match device_type {
		Device::Keyboard => {
			build_cfgs.check_cfg("keyboard");
			build_cfgs.enable_cfg("keyboard");

			build_cfgs.check_keyboard_mcu_cfg();

			qubit_config::cargo::output_cargo_instructions(
				mcu,
				&device::ROW_PINS,
				&device::COL_PINS,
				device::LED_PIN,
				&mut build_cfgs,
			);
		}
	}

	build_cfgs.check_cfg("has_led");
	if device::LED_PIN.is_some() {
		build_cfgs.enable_cfg("has_led");
	}
}
